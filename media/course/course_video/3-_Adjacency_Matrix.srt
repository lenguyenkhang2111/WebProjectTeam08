1
00:00:02,266 --> 00:00:04,599
we have two ways to implement a graph in code

2
00:00:04,666 --> 00:00:05,133
in this video

3
00:00:05,133 --> 00:00:06,866
we're going to talk about the first approach

4
00:00:06,866 --> 00:00:08,299
and we'll look at the second approach

5
00:00:08,300 --> 00:00:09,300
in the next video

6
00:00:10,366 --> 00:00:12,866
one way to represent the edges in the graph is

7
00:00:12,866 --> 00:00:14,099
using a matrix

8
00:00:14,100 --> 00:00:16,100
or a two dimensional array

9
00:00:16,333 --> 00:00:19,299
using this matrix we can see how nodes are connected

10
00:00:19,700 --> 00:00:20,700
so for every known

11
00:00:20,700 --> 00:00:23,500
in our graph we're gonna have a row and a column

12
00:00:23,600 --> 00:00:25,100
if two notes are connected

13
00:00:25,100 --> 00:00:27,966
we mark their intersection with a one or a true

14
00:00:28,366 --> 00:00:30,899
so here we can see that john is connected with mary

15
00:00:31,000 --> 00:00:32,400
bob and alice

16
00:00:32,500 --> 00:00:34,866
this is what we call the adjacent c matrix

17
00:00:34,900 --> 00:00:36,400
it's fairly easy to implement

18
00:00:36,400 --> 00:00:38,566
all we need as a two dimensional era

19
00:00:38,866 --> 00:00:40,466
but the problem with this approach

20
00:00:40,466 --> 00:00:42,899
is the amount of space we need to allocate for this

21
00:00:42,900 --> 00:00:45,066
matrix if you have n notes

22
00:00:45,066 --> 00:00:47,933
our space complexity is gonna be n squared

23
00:00:47,966 --> 00:00:49,399
that can grow very fast

24
00:00:49,533 --> 00:00:52,066
for example if you have 1000 notes

25
00:00:52,100 --> 00:00:54,733
our matrix is gonna have 1 million entries

26
00:00:54,933 --> 00:00:56,866
the approach we're going to explore in the next video

27
00:00:56,866 --> 00:00:58,066
will solve this problem

28
00:00:58,066 --> 00:00:59,866
but let's continue studying this approach

29
00:01:00,000 --> 00:01:01,900
because it has its own merits

30
00:01:02,100 --> 00:01:02,933
now let's talk about

31
00:01:02,933 --> 00:01:04,699
various operations we need to perform

32
00:01:04,700 --> 00:01:06,200
and their time complexity

33
00:01:06,566 --> 00:01:07,733
if you want to add a note

34
00:01:07,766 --> 00:01:09,466
we have to allocate a new matrix

35
00:01:09,466 --> 00:01:11,499
with one extra row and column

36
00:01:11,600 --> 00:01:14,500
and then copy all the existing items and this matrix

37
00:01:14,700 --> 00:01:15,566
into the new one

38
00:01:15,800 --> 00:01:17,333
how many entries do we have here

39
00:01:17,500 --> 00:01:19,766
n squared so adding a new node

40
00:01:19,766 --> 00:01:23,566
is an expensive operation and runs in o of n squared

41
00:01:23,966 --> 00:01:25,533
now we could optimize this by

42
00:01:25,566 --> 00:01:27,699
pre allocating a large matrix

43
00:01:27,733 --> 00:01:29,099
so we don't have to copy

44
00:01:29,133 --> 00:01:31,599
all these items every time we add a new note

45
00:01:31,600 --> 00:01:33,800
but again this is gonna waste memory

46
00:01:34,000 --> 00:01:36,066
also when talking about graphs

47
00:01:36,066 --> 00:01:38,466
we prefer to express the time complexity

48
00:01:38,533 --> 00:01:41,366
in terms of v which is the number of vertices or

49
00:01:41,533 --> 00:01:42,766
nodes in this graph

50
00:01:43,066 --> 00:01:43,966
as you will see later

51
00:01:44,066 --> 00:01:46,533
the time complexity of certain operations also

52
00:01:46,533 --> 00:01:48,499
depend on the number of edges

53
00:01:48,533 --> 00:01:50,966
so we use v and e instead of n

54
00:01:51,066 --> 00:01:53,599
when we do complex it analysis on graphs

55
00:01:53,966 --> 00:01:56,266
now what about removing a node or verdicts

56
00:01:56,466 --> 00:01:58,499
again we have to allocate a new

57
00:01:58,500 --> 00:02:01,000
smaller metrics and copy items around

58
00:02:01,066 --> 00:02:03,099
so we have all of v squared

59
00:02:03,566 --> 00:02:04,933
what about adding an edge

60
00:02:05,100 --> 00:02:06,200
let's say you want to add an edge

61
00:02:06,200 --> 00:02:07,933
which pin alice and john

62
00:02:08,366 --> 00:02:10,699
first we need to find the index of these notes

63
00:02:10,866 --> 00:02:12,199
we can use a hash table

64
00:02:12,200 --> 00:02:12,966
to store our

65
00:02:12,966 --> 00:02:16,133
note and their indexes in the adjacent symmetrics

66
00:02:16,166 --> 00:02:17,299
so in this hash table

67
00:02:17,300 --> 00:02:18,466
we map our notes

68
00:02:18,466 --> 00:02:21,199
to their indexes in the adjacent symmetrics

69
00:02:21,500 --> 00:02:24,100
if you want to add an edge with van alice and john

70
00:02:24,166 --> 00:02:26,366
you find your indexes using this hash table

71
00:02:26,466 --> 00:02:28,499
that's on all of one operation

72
00:02:28,933 --> 00:02:30,266
once we have the indexes

73
00:02:30,266 --> 00:02:32,499
we can quickly go to the corresponding item in our

74
00:02:32,500 --> 00:02:33,800
matrix and turn it on

75
00:02:34,166 --> 00:02:36,199
so adding an edge is pretty fast

76
00:02:36,200 --> 00:02:38,000
and runs in constant time

77
00:02:38,533 --> 00:02:39,899
what about removing an edge

78
00:02:39,966 --> 00:02:41,666
it's the same as adding an edge

79
00:02:41,666 --> 00:02:43,866
we have to go to a given entry in our matrix

80
00:02:43,866 --> 00:02:45,266
and set it to false

81
00:02:45,600 --> 00:02:48,066
how about checking to see if two notes are connected

82
00:02:48,133 --> 00:02:51,333
you want to see if alice and john are connected

83
00:02:51,700 --> 00:02:53,700
again we look up their indexes

84
00:02:53,700 --> 00:02:55,566
and read the value of the corresponding

85
00:02:55,566 --> 00:02:56,933
entry in our matrix

86
00:02:57,133 --> 00:02:59,099
this is an o of one operation

87
00:02:59,966 --> 00:03:01,999
another operation when it frequently is

88
00:03:02,100 --> 00:03:04,466
finding all the notes adjacent or

89
00:03:04,733 --> 00:03:06,166
directly connected to a note

90
00:03:06,166 --> 00:03:09,199
that means the neighboring notes in this matrix

91
00:03:09,200 --> 00:03:11,333
how can we find the neighbors of alice

92
00:03:11,600 --> 00:03:13,500
first we have to use our hash table

93
00:03:13,566 --> 00:03:15,933
to find the index of alice and our matrix

94
00:03:16,533 --> 00:03:18,666
now I need to look at every item in this row

95
00:03:18,666 --> 00:03:20,399
to find the connected notes

96
00:03:20,500 --> 00:03:22,200
how many items do we have in this row

97
00:03:22,333 --> 00:03:25,766
that is equal to the number of notes or vertices

98
00:03:25,933 --> 00:03:29,199
so finding the neighbors of a note runs in o of v

99
00:03:29,533 --> 00:03:30,333
and that means

100
00:03:30,400 --> 00:03:33,666
if you have 1 million people or notes in this graph

101
00:03:33,700 --> 00:03:36,266
and john is connected with only three people

102
00:03:36,366 --> 00:03:37,733
we have to check the connection

103
00:03:37,766 --> 00:03:40,499
between john and all the other 1 million people

104
00:03:40,566 --> 00:03:43,133
just to discover his three connections

105
00:03:43,333 --> 00:03:44,199
so overall

106
00:03:44,266 --> 00:03:47,666
the adjacent c matrix requires a fair amount of space

107
00:03:47,900 --> 00:03:48,900
but performs well

108
00:03:48,900 --> 00:03:49,866
if they need to add

109
00:03:49,866 --> 00:03:52,533
remove or quickly the existence of an edge

110
00:03:52,766 --> 00:03:55,133
finding the neighbors of a given note is a bit slow

111
00:03:55,266 --> 00:03:56,799
and runs in linear time

112
00:03:57,166 --> 00:03:58,666
adding and removing a note are

113
00:03:58,666 --> 00:04:00,266
the slowest operations and

114
00:04:00,300 --> 00:04:01,766
run in quadratic time

115
00:04:01,866 --> 00:04:03,799
so they're suitable if you know ahead of time

116
00:04:03,800 --> 00:04:05,266
how many notes you're gonna need

117
00:04:05,333 --> 00:04:08,066
and you're not gonna add or remove notes often

118
00:04:08,300 --> 00:04:09,733
in the next video we're gonna look at

119
00:04:09,733 --> 00:04:10,866
another approach for

120
00:04:10,900 --> 00:04:12,100
representing a graph

